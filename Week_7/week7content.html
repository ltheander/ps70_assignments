<!DOCTYPE html>
<html lang="en">

<title>PS70: Intro to Digital Fabrication </title>
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.1/dist/css/bootstrap.min.css" rel="stylesheet">
<link href="../style.css" rel="stylesheet">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/arduino-light.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.8.0/highlight.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/arduino.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script> 

<nav class="navbar navbar-expand-sm navbar-light bg-light">
  <div style="align-items: left; justify-content:left;" class="container-fluid">
    <h3 class="nav-title"> PS70: Intro to Digital Fabrication</h3>
    <div class="navbar-nav">
      <h4></h4>
      <h4><a class="nav-link" href="../index.html">Home</a></h4>
      <h4><a class="nav-link" href="../about.html">About</a></h4>
    </div>
  </div>
</nav>

<body>


<xmp style="display:none;">
<br> 

#### Week 7: Electronic Output Devices 
 
<br>

<h3>An Arduino-Based Proto-Keyboard</h3>

<p>Last week, I started learning how to produce sound with the Arduino and a speaker to start working towards my final keyboard project. This week, I wanted to continue to develop towards my final project by complexifying my design to produce a proto-keyboard, where pressing different button produces different frequencies out of a Piezo Buzzer. </p>

<p>I started by trying to make a proto-keyboard using an Arduino. The circuitry is fairly simple; a buzzer and each button is connected to ground and its own pin. When a button is pressed, a circuit is completed and the pin reads as low. Here is a picture of how the Arduino circuit works.</p>

![image of arduino circuit](./IMG-5088.jpg)

<p>The code is simple as well; when a circuit is connected and the pin reads as low, the buzzer produces sound according to which pin is low.</p>

<pre><code><p style="text-align: left;">
#define T_A 220
#define T_AB 233.08
#define T_B 246.94
#define T_C 261.63
#define T_CD 277.18
#define T_D 293.66
#define T_DE 311.13
#define T_E 329.63
#define T_F 349.23
#define T_FG 369.99
#define T_G 392

const int A = 2;
const int AB = 3;
const int B = 4;
const int C = 5;
const int CD = 6;
const int D = 7;
const int DE = 8;
const int E = 9;
const int F = 10;
const int FG = 12;
const int G = 13;
const int Buzz = 11;

void setup()
{
  pinMode(A, INPUT);
  digitalWrite(A,HIGH);

  pinMode(AB, INPUT);
  digitalWrite(AB,HIGH);
  
  pinMode(B, INPUT);
  digitalWrite(B,HIGH);

  pinMode(C, INPUT);
  digitalWrite(C,HIGH);

  pinMode(CD, INPUT);
  digitalWrite(CD,HIGH);
  
  pinMode(D, INPUT);
  digitalWrite(D,HIGH);

  pinMode(DE, INPUT);
  digitalWrite(DE,HIGH);
  
  pinMode(E, INPUT);
  digitalWrite(E,HIGH);
  
  pinMode(F, INPUT);
  digitalWrite(F,HIGH);

  pinMode(FG, INPUT);
  digitalWrite(FG,HIGH);
  
  pinMode(G, INPUT);
  digitalWrite(G,HIGH);
}
void loop()
{
  while(digitalRead(A) == LOW)
  {tone(Buzz,T_A);}

  while(digitalRead(AB) == LOW)
  {tone(Buzz,T_AB);}

  while(digitalRead(B) == LOW)
  {tone(Buzz,T_B);}

  while(digitalRead(C) == LOW)
  {tone(Buzz,T_C);}

  while(digitalRead(CD) == LOW)
  {tone(Buzz,T_CD);}

  while(digitalRead(D) == LOW)
  {tone(Buzz,T_D);}

  while(digitalRead(DE) == LOW)
  {tone(Buzz,T_DE);}

  while(digitalRead(E) == LOW)
  {tone(Buzz,T_E);}

  while(digitalRead(F) == LOW)
  {tone(Buzz,T_F);}

  while(digitalRead(FG) == LOW)
  {tone(Buzz,T_FG);}

  while(digitalRead(G) == LOW)
  {tone(Buzz,T_G);}
  
  noTone(Buzz);
}
</p></code></pre>

<p>While this Arduino-based proto-keyboard does the job, it has several limitations. Along with only being able to play one note at a time, the Arduino only has a limited number of pins to work with. In fact, with this setup, only 11 pins can be attached, not even enough for a full octave. I considered two possible solutions for this second problem; one is to multiplex the Arduinos pins and the other is to use a microcontroller with more input pins.</p>

<br>

<h3>An ESP32-Based Proto-Keyboard</h3>

<p>To get used to the ESP32 for future assignments, I decided to attempt to fix this problem using the ESP32 route. The circuit is extremely similar to the circuit for the Arduino, with the exception of having 13 instead of 11 buttons.</p>

![image of circuit](./IMG_5982.jpg)

<p>While I expected the swtich from the Arduino to the ESP32 to be very simple, I was very wrong. To start with, unbeknownst to me, the ESP32 I took out brand new from the packaging was broken. No matter what USB to UART driver I installed, I could not get any code to properly send to the ESP32 and it would overheat after only a few seconds of being plugged in.. After three hours of tinkering, installations, and attempts, Kassia had me switch to another ESP32 which immediately worked, leaving us with the theory that there was a missoldered connection on the inside.</p>

<p>Once this problem was worked through, I was met by another unpleasant surprise; the ESP32 does not support the same tone function that worked so well for the Arduino. After much searching through the literature, I was finally able to work out the code that allows for frequency generation in ESP32. However, every piece of example code I saw used the delay function. When I incorporated the delay function in my code, the keyboard worked perfectly. However, when I did not, the keyboard did not work at all! It seems as though in the ESP32 equivalent of the tone function, it is an instantaneous sound that must be extended through repetition. After much work, I finally settled on using the millis() function to provide a stall time to allow the frequency to run.</p>

<pre><code><p style="text-align: left;">
int freq = 2000;
int channel = 0;
int resolution = 8;
int period = 200;
unsigned long time_now = 0;

void setup() {
  Serial.begin(115200);
  ledcSetup(channel, freq, resolution);
  ledcAttachPin(14, channel);
  pinMode(1,INPUT_PULLUP);
  pinMode(2, INPUT_PULLUP);
  pinMode(3, INPUT_PULLUP);
  pinMode(4, INPUT_PULLUP);
  pinMode(5, INPUT_PULLUP);
  pinMode(6, INPUT_PULLUP);
  pinMode(7, INPUT_PULLUP);
  pinMode(8, INPUT_PULLUP);
  pinMode(9, INPUT_PULLUP);
  pinMode(10, INPUT_PULLUP);
  pinMode(11, INPUT_PULLUP);
  pinMode(12, INPUT_PULLUP);
  pinMode(13, INPUT_PULLUP);
}
void loop() {
  while(digitalRead(1)==0){
    time_now = millis();
    ledcWriteTone(channel, 261.63);
    while(millis() < time_now + period){
      Serial.print("waste time");
    }
  }
  while(digitalRead(2)==0){
    time_now = millis();
    ledcWriteTone(channel, 277.18);
    while(millis() < time_now + period){
      Serial.print("waste time");
    }
  }
  while(digitalRead(3)==0){
    time_now = millis();
    ledcWriteTone(channel, 293.66);
    while(millis() < time_now + period){
      Serial.print("waste time");
    }
  }
  while(digitalRead(4)==0){
    time_now = millis();
    ledcWriteTone(channel, 311.13);
    while(millis() < time_now + period){
      Serial.print("waste time");
    }
  }
  while(digitalRead(5)==0){
    time_now = millis();
    ledcWriteTone(channel, 329.63);
    while(millis() < time_now + period){
      Serial.print("waste time");
    }
  }
  
  while(digitalRead(6)==0){
    time_now = millis();
    ledcWriteTone(channel, 349.23);
    while(millis() < time_now + period){
      Serial.print("waste time");
    }
  } 
  while(digitalRead(7)==0){
    time_now = millis();
    ledcWriteTone(channel, 369.99);
    while(millis() < time_now + period){
      Serial.print("waste time");
    }
  }
    
  while(digitalRead(8)==0){
    time_now = millis();
    ledcWriteTone(channel, 392);
    while(millis() < time_now + period){
      Serial.print("waste time");
    }
  } 
  while(digitalRead(9)==0){
    time_now = millis();
    ledcWriteTone(channel, 415.30);
    while(millis() < time_now + period){
      Serial.print("waste time");
    }
  } 
  while(digitalRead(10)==0){
    time_now = millis();
    ledcWriteTone(channel, 440);
    while(millis() < time_now + period){
      Serial.print("waste time");
    }
  }
  while(digitalRead(11)==0){
    time_now = millis();
    ledcWriteTone(channel, 466.16);
    while(millis() < time_now + period){
      Serial.print("waste time");
    }
  }
  while(digitalRead(12)==0){
    time_now = millis();
    ledcWriteTone(channel, 493.88);
    while(millis() < time_now + period){
      Serial.print("waste time");
    }
  }
    
  while(digitalRead(13)==0){
    time_now = millis();
    ledcWriteTone(channel, 523.25);
    while(millis() < time_now + period){
      Serial.print("waste time");
    }
  }
  while(digitalRead(1)!=0 && digitalRead(2)!=0 && digitalRead(3)!=0 && digitalRead(4)!=0 
  && digitalRead(5)!=0 && digitalRead(6)!=0 && digitalRead(7)!=0 && digitalRead(8)!=0 
  && digitalRead(9)!=0 && digitalRead(10)!=0 && digitalRead(11)!=0 && digitalRead(12)!=0 && digitalRead(13)!=0){
    ledcWriteTone(channel, 0);
    Serial.print("while loop 3");}
}

</p></code></pre>

<video width="600" height="800" controls>
  <source src="muvid.mp4" type="video/mp4">
  <source src="movie.ogg" type="video/ogg">
Your browser does not support the video tag.
</video>

<p>While this code does work as can be seen in the video, there are still several problems prevalent in the ESP32 proto-keyboard. For starters, even though the millis() function does allow for sound to be produced, the loop in which the millis() occurs is obvious. There is a tiny pause between each loop which produces an unsatisfactory sound. Additionally, once the millis() loop is initiated, the sound must play out in its entirety, even if the button is not longer being pressed </p>

<p>While I do like how the ESP32 allows for a greater number of keyboard keys than the Arduino, I do not like how much more complex the code is and how the sound it produces is a much lower quality. Before my final project, I will have to work on multiplexing with the Arduino to get higher quality results with a greater number of pins.</p>

<br>

<h3>Oscilloscope</h3>


<p>Using the oscilloscope on the ESP32 proto-keyboard produces interesting, yet unsurprising results. When the oscilloscope is plugged into the buzzer and the ground, the frequency shown on the oscilloscope matches the frequency of the note played.</p>
![image of oscilloscope](./IMG_5987.jpg)

<br>

<video width="600" height="800" controls>
  <source src="osvid.mp4" type="video/mp4">
  <source src="movie.ogg" type="video/ogg">
Your browser does not support the video tag.
</video>

<p>This relationship makes sense as the ledcWriteTone() function works by sending pulses to the buzzer at the desired frequency. No matter what button is pressed, the voltage always sits between 1.6 and 1.7 volts.</p>

And here is a	[link to where the cover image came from](https://www.repairmagic.ca/components-desktop-computers/output-devices//).

</xmp>
</body>

<script src="../strapdown.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js" ></script>

</html>